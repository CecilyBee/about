---
title: "Episode 8: Rijnard van Tonder, creator of Comby"
publishDate: 2020-08-04T10:01-07:00
tags: [podcast]
slug: rijnard-van-tonder
published: true
---

<!-- START AUDIO -->
<audio className="object-center" src="https://www.buzzsprout.com/1097978/4755524-rijnard-van-tonder-creator-of-comby.mp3" controls={true} preload="none"></audio>
<!-- END AUDIO -->

<!-- START GUESTS -->
<span>
Rijnard van Tonder, Beyang Liu
</span>
<!-- END GUESTS -->

<!-- START SUMMARY -->
[Rijnard van Tonder](https://twitter.com/rvtond) is the creator of [Comby](https://comby.dev/), a pattern-matching syntax and command-line tool that offers a more expressive and more user-friendly alternative to regular expressions for many common patterns in code.

Rijnard earned his PhD from Carnegie Mellon University in 2019. In this podcast, we chat about the state of the art in static analysis and automated bug-fixing, new tools made in industry like Pyre and SapFix, and what place machine learning has in the world of developer tools.
<!-- END SUMMARY -->

<!-- START SHOWNOTES -->
Rijnard van Tonder: https://twitter.com/rvtond, https://rijnard.com

Comby pattern matching syntax: https://comby.dev

Comby Gitter channel: https://gitter.im/comby-tools/community

Program synthesis: https://en.wikipedia.org/wiki/Program_synthesis

Tree sitter: https://github.com/tree-sitter/tree-sitter

Codemod, from Facebook: https://github.com/facebook/codemod

Automated bug fixing and program repair: https://en.wikipedia.org/wiki/Automatic_bug_fixing

Chomsky's hierarchy (regular, context-free, and Turing-complete languages): https://en.wikipedia.org/wiki/Chomsky_hierarchy

Regular expressions, or regex (pronounced "REG-ex" or "REJ-ex"): https://en.wikipedia.org/wiki/Regular_expression

Holes in Comby (https://comby.dev/docs/syntax-reference) vs. named capturing groups in regular expressions (https://www.regular-expressions.info/named.html)

Rascal: https://www.rascal-mpl.org

Spoofax Language Workbench: http://www.metaborg.org/en/latest

Infer static analyzer, from Facebook: https://fbinfer.com

Rice's theorem: https://en.wikipedia.org/wiki/Rice%27s_theorem

SapFix, Sapienz, Mark Harman from Facebook (note: in the recording, we mixed up Sapienz with SapFix. SapFix is the end-user tool, Sapienz is an underlying technology which can be used to surface issues to SapFix): https://engineering.fb.com/developer-tools/finding-and-fixing-software-bugs-automatically-with-sapfix-and-sapienz/, https://engineering.fb.com/developer-tools/sapienz-intelligent-automated-software-testing-at-scale, https://research.fb.com/blog/2019/05/spotlight-session-with-mark-harman

Pyre, from Facebook: https://pyre-check.org
<!-- END SHOWNOTES -->

<!-- START TRANSCRIPT -->
<!-- END TRANSCRIPT -->


<!-- START CONVERSATION -->
**Beyang Liu:** I'm here with Rijnard van Tonder, the creator of the Comby pattern matching syntax, an alternative to regular expressions that's easier to use and designed and optimized for use in a code. Welcome, Rijnard.

**Rijnard van Tonder:** Thanks for having me, Beyang.

**Beyang:**  Before we get into the technical details, I thought it would be nice to tell the story of how we met.

**Rijnard:** Yeah, that was back when I was in grad school, at CMU and working on various research problems and very curious to explore new things, as you do in grad school.

At one point, Sourcegraph came up on my radar and I started playing with it. I thought, "Code search–that's cool." But I was also poking at security holes, trying to see if I could find them. There weren't any serious issues, but at one point I did find an information leak for the names of some private repositories, and so I reached out, and you were the one who replied to my email.

**Beyang:** Yeah, I remember you sent it to security@sourcegraph.com, and I was the one who replied.

**Rijnard:** So that kicked off a conversation about various things, like "Do you want to talk about what Sourcegraph does?", "Do you have any feedback about the product?", and so on. And I remember hopping on a call with a few members of the team. I thought Sourcegraph was really interesting, you were working on hard problems, and addressing a pretty big gap by creating code search that just worked, ubiquitously.

**Beyang:** I remember looking you up when you reported the bug, and I found that you were doing research into software engineering, developer tools, and static analysis. Afterward, we were email buddies for awhile. And then at some point, you came out to California to do an internship at Facebook, and you dropped by the office.

**Rijnard:** Yeah, that's right. At that time, Sourcegraph was doing a lot of things with LSP (the Language Server Protocol). And that tied into some of the things that I ended up working on at Facebook, working with Python, specifically on code intelligence and navigation in the editor.

**Beyang:** It was all very serendipitous. I knew very early on that I would love to work with you someday. And I'm really glad to be working with you now—you've brought some fantastic insights into what's on the research frontier to what we're doing at Sourcegraph. I suspect we'll get into some of that later in the conversation.

**Rijnard:** Yeah, thinking back, what I remember as well was that everybody I talked to at Sourcegraph was very keen to get feedback right—not just on the product, but also on the underlying idea of what would be possible if you had code search and code intelligence ubiquitously, everywhere you interacted with code. So there was never a dead end to the conversation I had with anyone at Sourcegraph.

I saw a deep desire to go after those goals of code search everywhere, code intelligence everywhere—every editor, every place you touch code. And so there was strong mutual interest and commitment to those ideas. So that's why I ended up here.

**Beyang:** Before we get into Comby and the other research you've done, can you share how you got into programming originally?

**Rijnard:** My first real programming experience was during high school. My final two years in high school, I learned to code in Java. I still remember my first programming experience was looking at this programming textbook, and I copied the program character for character into my editor. And then I ran it, and I got all these syntax errors.

I was like, "What? How did I make so many mistakes?"

And from there, I became more and more interested in understanding the theory behind those compiler errors, and general theory like algorithms, data structures—that sort of thing. And in university, I studied computer science. There, I was exposed to Linux for the first time, and with it, the power of the command line.

**Beyang:** Where along the line of your studies did you decide to pursue a PhD?

**Rijnard:** Oh, I think my story is similar to a lot of other grad students. I did a couple of Google interviews and it didn't work out, so I was like, well, I'm going to grad school now. And I got accepted into a few PhD programs, and so it all worked out.

**Beyang:** Yeah, I got rejected from Facebook myself. How did you pick your research area?

**Rijnard:** I was only interested in doing research if it was a topic that I really care about. The kind of stuff that stood out to me back then was software security research and automated program analysis for finding bugs. Bugs—and security bugs specifically—are super interesting because they have such severe consequences. The central question for me was: how far can we push automated techniques to find really complex, really interesting bugs. From there, it evolved and eventually changed a bit of direction, but that was the underlying interest.

**Beyang:** One of the things that you covered in your PhD research was a new pattern matching syntax called [Comby](https://comby.dev/). What is Comby and what were your motivations creating it?

**Rijnard:** Comby is a tool I wrote that solved a problem I encountered in my research at the time. I needed a code transformation tool that could change bits of program syntax without having to compile the whole program and was robust to things like malformed syntax in the rest of the file.

For example, I just wanted to be able to change the structure of an if-statement by, say, adding a clause to the conditional, or maybe adjust the halting condition in a for-loop. To make it concrete, consider doing this in Java. There are existing tools like FindBugs that detect common errors and anti-patterns and suggest changes. My research was in identifying new types of errors and, in order to close the loop, I wanted to enable the user to have a one-click way of applying the suggested changes.

Regex is not powerful enough to describe these transformations precisely in a way that generalizes across all situations. There are tools that *can* express the transformation 100% precisely in terms of the Java AST. I initially tried to use one of these parser-based tools. But what I soon realized is, if I wanted to change a particular statement, I couldn't do it without parsing the whole program. I couldn't even parse just a single file.

I remember going into the community Slack channel for this tool, and I asked them how could change this one small thing without doing anything super complex, and the response was something like "Well why would you want to do that?"

And that's fine, because these tools are made for particular reasons, and the reason I wanted to use it wasn't aligned with the reasons for which the creators had created it.'

So I was left thinking about how I could parse these code fragments I wanted to transform. And the thinking was, how can I transform these fragments into a general parse tree that preserves some of the syntactical tree structure of the language and understands things like balanced braces and parens. And you also have to take into account things like comments and string literals, because you need to treat those cases differently.

If we can approximate the tree structure of the program in some way that's easy to manipulate, then we would have something expressive enough to apply all the transformations I wanted to make but also general enough to work across many languages *and* easy-to-use for the end user who may not want to run a whole compilation pipeline to apply these transformations.

There are a few tools that take more of a language-agnostic approach—[Tree-sitter](https://tree-sitter.github.io/tree-sitter/) is an example—but I wanted something even lighterweight to use and understand.

**Beyang:** Let's lay out the spectrum of pattern matching and replacement tools. On the far end of the spectrum, you have the full-on compiler-based or static-analysis-based tools, such as the Java tool you mentioned. With these tools, you express your transformation in terms of changes to the compiled AST. And then on the other end of the spectrum, you have things like regular expressions and tools like `grep` that use regular expressions. Is that an accurate book-ending of the spectrum?

>>> HERE

**Rijnard:** In my mind, there are at least two axes. The one you pointed out is expressivity. In other words, what is the set of transformations i can express? Regular expressions is on one end of this axis. And you can map some notion of expressivity to something more formal like the [Chomsky hierarchy](https://en.wikipedia.org/wiki/Chomsky_hierarchy).

**Beyang:**: Chomsky's hierarchy is a hierarchy of languages from regular languages to context-free and all the way up to Turing-complete languages?

**Rijnard:** Right, it's a way to describe levels of distinct capability and computational power. So a context-free construction is something like balanced parentheses. These can't be recognized by regular expressions, but they can be recognized by the compiler. Most programming languages are at least context free and you have some that are context-sensitive, where they need to take into account things that might have been defined elsewhere in the file—typedefs in C, for example. Regular expressions can be extremely fast and compiling can be comparatively slow.

So that's one axis, the axis of expressivity. But there's also a second axis of ease of use. With Comby, I didn't want to have to write up a program or script or Clang plugin in order to express the transformations I wanted to express. I wanted something simple and lightweight. And even with something like regular expressions, there are a lot of gripes about the syntax. With actual tools used by humans, it's not only about expressivity. Design choices and tooling choices come into play and are a big part of whether a tool is adopted and succeeds in its intended domain.

**Beyang:** So Comby, if I understand correctly, is a syntax and tool that hits a sweet spot in this two-dimensional space of expressivity and ease of use. It's expressive enough that you can describe 98% of the patterns you want to match in code, but at the same time, it has this ease of use, this "developer ergonomics" factor that makes it a lot easier and intuitive to write patterns compared to regex, which every developer I know has a love-hate relationship with.

**Rijnard:** Yeah, the goal is definitely to make Comby lightweight and as declarative as possible. I made the decision not to allow meta-syntax or escape characters for usability reasons. Over time, however, I've come to recognize that it's very useful to also match some lexical constructs, which regular expressions are very good at. And so why reinvent another language? So the latest version of Comby allows you to optionally embed regular expression syntax into it to match things like certain character classes.

I've strived to make it so the defaults work nicely in each languages, so you're not spending time defining "this is what a function looks like in Erlang" or "this is what a block is in Ruby". So it is language-specific at some level, but it's at the syntactic level rather than the semantic level where it actually understands what a function block is. So there is a way to identifying syntax that corresponds to the underlying language construct you're interested in matching.

**Beyang:** So it handles things like balanced delimiters, string quotes, parens, brackets, and other common patterns in code. Those types of patterns are super annoying to define in regex, because regular expressions have not concept of "memory", so they can't keep track of how many nested parens deep you're into an expression. Comby understands these constructs at a foundational level and makes it easy to express transformations like switching the order of arguments in a function call. Maybe you could describe the notion of "holes" in Comby. In your Comby pattern, you insert holes (e.g., `myFunction(:[1], :[2])`), and the syntax looks like actual code. And then in the replacement pattern, you reference the holes by their number (e.g., `myFunction(:[2], :[1]`).


**Rijnard:** Yeah, holes in Comby are analogous to named capturing groups in regex. But in regexes, I don't think people use named capturing groups a lot for changing code. Maybe I'll use capturing groups, but I probably won't assign a name to it, and that affects readability immensely. For example, if I write a regex to match, say, telephone numbers, and I don't name the capturing group and I hand that to you and say, "Hey Beyang, here's the regex," you probably have no idea what it's matching and it will take you awhile to figure out what the regex does and what the structure is.

So holes in Comby let you identify and rewrite pieces of code in a structural way. Maybe you want to identify calls inside of a for-loop, or inside double-for-loops or nested for-loops.

A concrete example is finding instances in code where you're compiling the same regular expression inside of a for-loop. This is a fairly common anti-pattern. It's wasteful; you should just move the regex compilation outside the loop and reference it from inside the loop. Ironically, it's very difficult to regular expressions to identify such instances, but with Comby it's quite easy.

**Beyang:** And just as a reminder, Comby is not just a syntax. It's actually a command-line tool, as well, so if you go to https://comby.dev, you can just download and try out the tool.

**Rijnard:** Right.

**Beyang:** What sort of use cases of Comby have you seen in the wild?

**Rijnard:** You know, it's interesting. I think there's a wide array of things that people think to do once you give them this tool that let's them easily change their code in certain ways and that it's more sophistocated and expressive than regular expressions. You end up with a lot of interesting and unexpected ideas.

One example use case is people who want to use the tool interactively, by paging through each proposed code change described by the Comby pattern. So maybe the pattern you wrote doesn't correspond exactly to what you want to do, so you need to check each case, or maybe you want to skip cases that occur in test code. Codemod, the open-source tool from Facebook, I think was the first tool to support this interactive mode, and Comby took some inspiration from it.

Another thing people want to do is changing things inside of HTML tags—classes, attributes, and that sort of thing. This was a use case that demonstrated to me that supporting regular expressions in submatching patterns was useful, because people want to match their arbitrary character classes *within* angle brackets or strings matched by Comby.

**Beyang:** How much do you find yourself reaching for Comby in day-to-day find-and-replace tasks versus something like `grep` or the find-and-replace functionality of your editor?

**Rijnard:** That's an interesting question. Currently, I mostly use Comby for high-level applications rather than everyday ad hoc tasks, though I have used it a fair bit through Sourcegraph.

There have been a couple of times where I wanted to change a bunch of test cases that are all very similar. Maybe each of these test cases has a struct field value that I want to replace.

But the biggest appeal for Comby currently for me is for these rarer, more complex changes. For example, mutation testing. For the unfamiliar, mutation testing is this idea of transforming your program, running your test suite, and if you're test suite doesn't detect anything bad, you've essentially created a mutant program that reveals a gap in your test suite.

So you can imagine being easily able to change programs in this scenario is very useful. There's a lot of academic research in this space and a lot of tooling associated with this as well, and traditionally you had to use a more heavyweight tool to apply these transformations or focus your attention on one or two languages like Java or C. With Comby, you can do this in a more general, language-agnostic way.

>>>>>>>>>>>>>> - 30 -

**Beyang:** I myself have tried to use some of those more kind of, um, heavyweight, uh, refactoring tools that actually hook into the AST. And my experience is that it's, this is quite a, like a learning curve. Um, cause you, you kind of have to like learn the ins and outs of the EST and in order to ensure that you can actually like express the pattern that you're trying to, um, describe, and it's, it's almost, um, There's a greater mental barrier, because like, when I think about the pattern that I want to, to match, oftentimes it's like at a kind of textual or a syntactic level, like, Oh, you know, switch these arguments or, Oh, you know, add another argument at the end of this function.
Or, you know, move this struck, rename this struck field or something like that. And. Uh, I'm not really thinking about like which AST node specifically I have to modify and like a w which kind of like layer in the tree that might occur and what are all the other like hidden AST nodes that I don't even know about, but are kind of like implicit, implicitly constructed, uh, when, when the language gets parsed, um,

**Rijnard:** for sure. That's part of it, right? Like, um, clang has an excellent like query matching or way to match. Kind of C, C or C plus plus syntax with a query language. So, you know, they, they recognize that, okay, visitors, you know, writing a plugin or. Uh, you know, that does a programmatic thing using a visitor to face those kind of heavyweights sometimes.
So we're gonna introduce this queer language, but in order to use this career language, you, you have to be familiar with all of the grammar constructs to make sure that you're not you're matching on this, this, this specific thing in the C plus plus grammar that you're actually interested in. And many of the time you might not even know that, you know, the.
The L value for assignment corresponds to the left hand side. It's it's, it's very heavyweight. So, um, yeah, as a, as a, what I would say a declarative technique allows you to do is kind of what you see is what you get, right. Um, And, uh, that's kind of the aim here. Now. Of course, there are many tools again, out there that do declarative, like transformation and matching, um, especially on the academic side.
So, uh, you can find tools like a rascal and, um, uh, spoof is like a language workbench. Uh, Uh, that, that, that covers a lot of languages. And you can kind of define all of these declarative ways to, to match a syntax. But, uh, at the end of the day, either have to like dig up the thing that you want or, um, or kind of learn a little bit more context about those tools and, and with come, is this thing that basically I wanted to just, just to be you a brew install, and then run thing that I care about and not.
Pay too much attention to, you know, is this like a, a, you know, a fully fledged parser? Is this, did someone go and make the effort to turn this into a, you know, a declarative way to, to specify things for Java or whatnot?

**Beyang:** I want to return to kind of, uh, an earlier use. Okay. So like, you know, we've talked a bit about how this can make the lives of people who are doing kind of like serious refactors, um, easier. Um, so like people who, who would use more, more of a heavyweight tool, um, we didn't exist, but I kind of want to return to that, like every day yeah.
Use case that kind of like rejects replacement. Use case, um, cause you know, you said you don't, you don't use it every day. Um, I, I actually find myself using it more and more often. And I do wonder whether like it, in my view, there's kind of this hurdle that like any new everyday tool has to, um, Overcome, which is kind of like the familiarity, a hurdle, right?
Like the people who have already invested, uh, many hours of our lives into learning, uh, rejects, uh, syntax and all its, you know, special variants. Uh, that's kind of like a thing that, you know, we already have and now along comes like a new syntax and it's like, Oh, you know, do I really want to learn this a thing that I have?
You know, it's not perfect, but it works reasonably well. Um, but I do wonder, because I know a lot of other programmers, both, um, new and, uh, some  fairly experienced who actually have avoided rejects, uh, so far. And it's like something that's kind like scary to them. And I almost feel that like Komi would be.
In, in many ways, like a better starting pattern, matching syntax. Cause it's just more intuitive to use. You can kind of like parse it with your eyeballs. You don't have to go and like upload it to one of those, like rejects visualizers to figure out what the heck is going on. Do you think that Comby like will evolve into a tool like that, especially for beginners where they kind of use it, in more of everyday setting.

**Rijnard:** I am very happy to, to see that happen, but it's not, not, I wouldn't say that that's kind of an end goal. Um, at least to the extent of, you know, I'm not, I'm not pushing for the tool to be adopted by, let's say novice or unfamiliar, um, uh, you know, programmers, it's, it's, it's more a question of, you know, The tool is designed to do something in a simple way, something more complex than reg X allows in a, in a simpler way.
And I think you can, you can absolutely hone in on, you know, how do I make, how do I make it minimally simple for people to do X, um, as far as matching or transforming code goes. Uh, and I, and I think that would, that would, you know, at some point you're going to come up to you. Yeah. Your, your tool's gonna sacrifice something in the interest of simplicity.
So, um, my, the kind of thing that's top of mind for me for designing, you know, syntax for comas, make it dead, easy to kind of, you know, match code and make things correspond to code. Um, uh, but at the same time, you know, that there've been more and more kind of examples where. You know, once you start using the tool, you want something more out of it.
You want to, maybe here's a, here's a concrete example, right? It's like, Hey, I want to, I want to sort my, my list of imports in my program alphabetically. Right. Um, and so com can make it super easy for you to like match all the import statements, you know, within some like import, uh, group. Parenthesize in per group and go for example.
Um, but it doesn't, it doesn't have any native capability to go and say, okay, I have a list or a set of lines that were matching. Now. I want to sort these less lexical graphically, right? Like that capability doesn't exist. And, and you could pipe that stuff into another program and then, you know, rewrite and, and that that's something you could do.
But, uh, the point kind of here is, uh, at the end of the day, It's good at doing one thing really well, which is , match, you know, syntax that corresponds to code structures, and then whatever comes on top of that, um, you know, I'd love to support things. And branch out capabilities, but you have to kind of draw the line somewhere.
And I think the same thing happens essentially, when you say, Hey, I want to make this thing super accessible, right. To people who don't, who don't know regular expressions. And I, and I don't know what the, the shape of that solution looks like, but, um, certainly some of the designs and decisions around the syntax of Kobe, you know, uh, advocate for, for, for a solution like that, 

**Beyang:** Yeah, that makes sense. Um, I want to kind of take a step back and like chat about some of the other research that you've done, but before we move on to that, I think it would be remiss of us if we were not to mention that, uh, the commies index is actually afforded in Sourcegraph, uh, currently. So if folks want to try that out, you just go to  dot com and in the search bar, it's kind of like the, um, bracket icon, uh, called structural search.
And so if folks want to try that out, we'd love to hear feedback on that.

**Rijnard:** Yeah. And I'm looking to put out more examples of that, uh, as well. Um, so, uh, yeah, go find interesting things. Uh, try it out, give us, give us feedback and, uh, And, uh, the, the benefit is there that you don't even have to clone your repos. You just, you know, we have repos up there and, uh, you can search, you know, for example, some of the more, more popular get hub repositories, uh, Java go of hyphen, all these things.
Um, so yeah, it works out of the book.

**Beyang:** Yeah, actually, just a quick question on that, like in implementing that syntax for Sourcegraph, did you have to do anything special to get it to scale?

**Rijnard:** Um, well,  we're doing some we're, we're doing some fancy things, uh, leveraging, you know, the fact that we, we have indexed, um, a lot of source code already. Um, I can, I can look up, you know, in certain files, whether, whether a fall at all com contains, you know, strings that would match.
So, uh, There are various kind of optimizations that I worked on. Um, and they'll tend to, to kind of identify that, that sort of thing. Right. Um, and it's not, it's not any kind of, it's not any different than, you know,  whipping out like rip grip and then, you know, finding files that you want to search.
And then, uh, you know, finding that in Tacoma. But, but the benefit is on, on search gas.com of course, that, you know, we do trigram indexing, which is even faster than, than rip rap. So. Um, uh, so that, that's why it works really well out of the box.

**Beyang:** Cool. Um, yeah, but, uh, so with respect to, you know, the other research that you've done, uh, my understanding is that you, you wrote Comby because, uh, you were having trouble with, um, Like a pattern matching and replacement because of another aspect of, uh, of your, your research. Um, can you tell us about like that, uh, I guess initial motivating problem and, or maybe just like about your, your thesis in general and what were kind of the themes there?

**Rijnard:** Yeah. So my, my high level focus was to. Take take existing tools that we have out there that are fairly popular and use fun practice, uh, to, uh, to find bugs. Right? So to find bugs that are a little bit more sophisticated at a, at a semantic level, right? So not, not your, Oh, I'm missing a semi-colon or, um, you know, I.
I have some, you know, Lindt check that that's failing, but, um, something more in the line of, Oh, you forgot to close this file resource. And maybe you've, you've opened up a follower, a socket and you know, one function and then three. Function calls deep. You're done with this thing, or you've turned up the stack and you forget to close it.
Right. Um, so, so from a program analysis perspective, this gets pretty complex because now you have to consider, you know, um, calls across multiple functions, uh, different contexts in which a function is called. Um, you know, whether, whether there any logic inside of, you know, if conditionals are four loops change, whether you.
Close the file later or not because you don't want false positive. You don't want the analyzer telling you, Hey, you didn't close this file, but then you did. And they analyze there's too dumb to know the difference. Right. Um, so, uh, That's the flavor of maybe the sort of bug that you want to fix. And so, so, uh, I went and dove in and said, okay, given that an analysis run, it knows things.
It has reasoned that, you know, there's, there's this bug that happened. How can we go about fixing that automatically? So we want to make some change to the program and, and fix this bug in a way that's that we can have a reasonable amount of confidence, uh, that, that it fixed, uh, that it is fixed. And so, um, Don't have a lot of detail to that.
Uh, and I, and I won't necessarily go into all of it, but basically you leverage the fact that, you know, a static analysis. And so in this case, I used a tool called Infor, um, which is also open source on GitHub. Um, uh, and that's maintained by Facebook. Uh, I think it's a great tool to have out there. And, um, you know, it finds this sort of bar Gregg resource leaks and, and.
And, uh, uh, memory leaks and C C programs and so on. And so. Um, I w I was using that as like one tool as a basis of, you know, trying to automatically fix the bugs that reports. And so at the end of the day, you can use some of the things that the analysis inferred about your code to also inform a fixed, right?
You can, for example, identify places in the code that also close the file on some condition. Um, and you can identify that, uh, you know, in that, in the analysis output, But, but once you have that, right, it's like, okay, I'm ready to make a change. I'm ready to change the program. Uh, and that means you have to make a syntactic change, right?
Like at some level, this stuff has to translate into some tactics, change the program. Okay. So you're like, I'm ready for this. I just need to add this like close, close socket inside this if condition. Right. This is what I need to do. And it's like, okay, how can I, how can I match on the body of this if condition, um, you know, reliably?
So I can just insert, and this is, this is kind of, uh, around, into this problem, which is like, okay, I know everything that I need to know what I want to do. It's just. It's just not easy to just do this one thing, right? Like I just got on matches this if conditions, body inside these braces, but I can't because they're there they're too many parentheses in the, and they have conditioner too many bracelets inside that confused rug.
Like I tried regular expressions at first was like, maybe I can get around those. Maybe I can just, so it's a research problem. This isn't like part of a novel or a significant contribution. I just, I just wanna, I just wanna. Do this change. Right? And so this is where I got

**Beyang:** you thought finding the issue would be the hard part and then actually making the change would be easy, but it turns out making the change was a lot more annoying.

**Rijnard:** Yeah, absolutely. Um, and so, and it's so big, it became, this is kind of thrown in my side. Right. Um, and, and that, it was at that point where, you know, That I ended up using, I think a, you know, a specific Java thing at that point. But, uh, but I came out of that thinking, you know, this is ridiculous. Um, I'm not doing that again.
And this is actively hindering, like other things I want to do in my research. So I'm going to go build this tool. Um, and that's kind of how it, how it sprung out and, uh, uh, yeah, it was, it was kind of a built around that purpose. Um,

**Beyang:** that Mo motivating problem is really interesting cause like the kind of magical, uh, uh, like the, the thing that I've used is probably closest to that. It would be like find bugs in, in the Java world. But like, when you get suggestions like that, where it finds like actual bugs in your code, uh, and flags them to you, that is almost like.
Uh, the first time you see that it's like a wow moment. You're like, wow, this is magical. Uh, it knows what's going on in the code. Uh, and I think like these days you see more and more kind of, uh, stronger claims being made about what actually can be done. I think you and I have chatted length about, uh, like machine learning for instance, is, is, uh, A topic or buzzword, that's thrown about a lot these days and I've seen it.
Yeah. Used, um, a number of times in, in the specific domain. Yeah. And like code transformations and, you know, automatically writing programs. Um, which admittedly, you know, would take it a step. Yeah. Even just the like kind of semantic analysis and transformation. Uh, we've chatted about this at some length. I I'd be curious to, if you could share your thoughts with, um, the podcast audience about like, um, the intersection of machine learning and, uh, like, uh, language analysis, um, and, and, uh, programming automation.

**Rijnard:** Yeah, I'll scope it a little bit more to, I'll only kind of comment on, I think, you know, the, the interesting aspects around, you know, can we use, for example, machine learning to automatically generate or fix programs? I think I'm more familiar with the kind of, uh, effort around automatically trying to fix programs, uh, using, for example, machine learning.
Um, And I think there's also a distinction between, you know, uh, applying machine learning in industry, you know, uh, scenarios versus academic. Yeah. It's around machine learning. So, uh, to me it's a, it's a, it's a matter of, well, there are many, uh, approaches that say, well, okay, we, you know, programs are just.
Data, and we're going to feed it into, you know, some supervised learning, um, algorithm. We're going to get some outputs and we can use that. Right. And show that the results is useful for some context. And you can absolutely do that for something like, you know, uh, uh, automated program, repair, automated book fixing.
Um, but, but, but I think the, the challenge here is that like, if you treated it like a black box, right, you. A, the stuff you're going to get out is going to be kind of a function of, you know, the fidelity of things that you fit into it. And, uh, uh, you know, if you're just treating it as, as text, then you're, then, then there's only, you know, there's an extent to how good you can do.
Um, but when you go to the office, um, and so, uh, this, despite the tendency to, you know, just, just throw things at, at. A machine learning algorithm w which happens right in research. And I think it's not, it's not, it's not totally unreasonable to report on those results and say, Hey, you know, uh, uh, observe this.
And it's sort of, it's full maybe. Um, Oh, we're not really sure. Right. But, uh, I think it's important to caveat that and say, well, um, Programs are a lot more structured. That's why they're so interesting. And we have a wealth of, you know, history on, on, on program analysis and research that, that really dives into, you know, what's, what's the complexity, what's the underlying, uh, complexity of the thing where we're dealing with this problem that we're trying to solve.
And, um, I mean, it's, it's already been proven at a, at a formal level, um, that, you know, uh, any sufficiently interesting property is impossible to, to. To, to detect in general. Right? And so there's this corresponds to rice as theorem. And I don't know if you're interested in that. You can go, go dive into that.
But the point is like, uh, neither machine learning or anything else can actually solve this at a very general level, but we can do pre pretty dang good. If, uh, If we reason about what we can and cannot do in certain contexts, right. And, and what approximations we're going to make. Um, and so I think machine learning as, as a, as a tool to solve a wrong, and there's a very course, uh, unless you encode all of this stuff that we know.
And so one of these things that we know about programs is they have structure. They have a grammar, they have, uh, you know, uh, various attributes and semantics around certain buggy properties. And so, um, I think kind of the research space is split between those two lines of thought, right? It's like, uh, do we, do we.
Do we come from the perspective of, okay, we're sharing this as a program, uh, as a foundation that's, you know, logical or able to reason about and model maybe, you know, just great sense, uh, versus, okay. We have a very powerful kind of inference engine, but it's, it's, you know, it is, uh, it is based on kind of, you know, uh, Elements that, that, that we're not going to reason about or necessarily yeah.
Incorporate, you know, ex or explain how we arrived at a certain result. Um, and so my hope is, you know, these, these two things converted, um, and get, get closer to each other. They're a bit detached. And so, um, of these two camps, right. I fall very much into the like, you know, study and research programs as a, as a.
As a, as a structured or logical concept. Um, and then, uh, maybe on top of that, you know, implement various, uh, ways to, to do something like machine learning or, or other AI approaches to, to, um, to, to kind of reveal interesting properties or, or, or, uh, ways of fixing programs. Right.

**Beyang:** Yeah. Are there any efforts, either an industry or academia that you're aware of that, um, in your view, are, are taking kind of the right approach of synthesizing these two worlds?

**Rijnard:** I don't know so much about synthesis. I think an inch, I don't know of any good examples right now, at least that, that I can point to. I will say that, you know, In terms of, you know, where we are going with automated reasoning and things like, you know, uh, being able to do generate programs automatically or fixed programs automatically, you know, are we, are we going to put software developers out of jobs or are they gonna, you know, at some point, uh, you know, uh, we're, we're not gonna need certain types of software developers or engineers, uh, in terms of that, I think it's clear that, you know, we're.
Where we're not quite. And I don't see us getting there anytime soon, you know, uh, automating a way, any substantive, uh, engineering, uh, ability. Um, what we are doing is getting closer to kind of, uh, you know, removing the TDM around certain bug fixes and reasoning about some. Um, uh, pieces of code and also just, you know, engineering oversight.
So it's like, you know, you're coding, you're trying to, you're just trying to, you know, implement some new interface to call out some other code that, you know, Or removing a feature flag or something like this, uh, and then bugs crop up. And it's like, I don't want to deal with this right now. Are you, maybe you're not thinking about that right now, or it's not in your mind right now.
And then an analysis tool picks that up. Right. And that's really where the value is. And that's really the gap I see, kind of the tooling and an automated nature of, of software analysis going is really to, to make us more effective at, at. Working on the core of the problem. Right. And the core of our day jobs, we don't want to deal with all the TDM and the, the, you know, do I have to check this thing?
Whether it's all again.

**Beyang:** the knowing parts of the job, we want to focus on the creative and fun parts.

**Rijnard:** Yeah. So as far as, you know, successful efforts in industry, I think, um, Since I was at Facebook and then I kind of follow along the research. That's adjacent to some of their stuff. Um, I think they're really doing well at, you know, Doing kind of automated program, air, automated bug fixing for these more sophisticated, uh, classes of bugs that I mentioned.
Um, and so, you know, they're, they're looking at things like, know the references, you know, for, for Java and so on and automatically fixing them, incorporating that into. Uh, their CIA and, uh, you can go look up on the internet. There's a project called sapiens. So Mark Harmon and his team behind that, um, you know, they, they do some pretty interesting stuff where it's really like, kind of at this frontier of, okay.
We're at the point where we can kind of change programs and they result in kind of. Mostly reliable or at least feasible fixes to bugs that we are willing to show to developers and say, Hey, does this fix your issue? And you know, it becomes this kind of push, push button approach, um, to, to automating these fixes.
And that's really what I also kind of went after in my research. It's like, can we, can we achieve this idea of like push button program pair where we have. Enough confidence about a buck fix that we're willing to show it to developers, uh, and, and say, Hey, we actually, we actually tested this, right? Like this, this fix, um, Stopped this test from failing or this fixed stops this analysis from reporting a bug and we have high confidence that this is an actual issue.
Um, and so I'm excited to kind of see that expand. And I think it's a question of, you know, when it's, uh, it's going to happen eventually where we see more of this sort of. Tooling, um, kind of crop up and it's very much going to be, I think, a function of, you know, integrating with a developer's workflow, whether that's CGI or in their editor, or, you know, a tool that they use to search a review code.
Um, that's really going to be the. The interface to this sort of interaction, um, where, where you, where you interact with an automated tool and what did, um, there's going to have to be yeah, yeah. A human in the loop for a lot of it. And I see that, uh, factoring into, especially things like your CGI workflow, um, and editors.

**Beyang:** You mentioned that you worked, uh, at Facebook, uh, forbid I believe he also did stints at, uh, MSR and, uh, Google, if I'm not mistaken, um, of those three, uh, companies, uh, you know, w w we'll have a short time left, but like, are there any like, projects that you think are worth calling out there that were particularly interesting to you in, in the space of developer tools?

**Rijnard:** Yeah. So my focus became more specialized, I think, as I, as I did more of these internships. Right? So, um, I think the, the most recent and most kind of focus to, to, to my, to my interest in speciality was a Facebook, right? So I worked on, you know, uh, Pyre, which is a static type checker for Python. Um, and it's really interesting to me that, you know, over.
Over time. Facebook has kind of gone and been very, very much, uh, investing in tooling, right. Um, uh, for software qualities, things like bug detection type checking for Python and this sort of thing. And, uh, I th my impression is, you know, Facebook is kind of at the forefront of doing this a Google, a Microsoft, for sure.
You know, they invest in their tooling and, uh, and a lot of it's great, but, um, I think a lot of, you know, Talented researchers and, and, uh, You know, engineers, uh, are working on these tools that have really impressive results. So finding, uh, anything from super sophisticated bugs and, and hack that, you know, could lead to, you know, Facebook servers being compromised or, or, you know, just daily developer, a I missed the, uh, no, the reference check.
Um, they've, they've really kind of covered a broad space of it. Um, I think Amazon is also now ramping up a lot of, of their dev tools and program analysis efforts. Um, but, but certainly, uh, it's been interesting to see, uh, you know, Facebook as a, as a social media company at the end of the day, really investing so heavily into software quality dev tools.
And so that to me just says, you know, Uh, this is, uh, this is, if it isn't already, it will be a ubiquitous concern for any software company, right? As you grow, as you, as you understand the complexity of, of, you know, what you're, what you're doing and what your software and, and the, the activities that your engineers are engaged in, um, it becomes a critical piece that has to integrate with, with what you're doing.
And if you're a company that. That isn't aware of that yet. Right? It's a bit of a, um, and I think this problem becomes more important as you grow, obviously like the size of your company matters. Right? And so that's really where the value of these automated tools like automated bug fix is automated by finding come into play is as soon as you reach a scale where you want to cover a lot of, a lot of ground and a lot of the complexity, um, of like, you know, millions, billions of lines of code.

**Beyang:** If a folks listening, want to learn more about, um, Comby or any of the research that you've done, um, how would you recommend they go about doing that?

**Rijnard:** Uh, the easiest way is probably to just find me on Twitter or just DME on Twitter. Uh, and then we can, uh, fire off an email exchange. If that's, that's something that, you know, you're open to, or you want to chat more in depth. Um, So you can find me on Twitter at RV T O N D.

**Beyang:** Cool. And we'll put that in the show notes as well.

**Rijnard:** Sure.

**Beyang:** My guest today has been Rijnard van Tonder. Rijnard, thanks for being on the show.

**Rijnard:** Thanks Beyang.
<!-- END CONVERSATION -->
